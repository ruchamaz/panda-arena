<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>פנדה בזירה</title>
  <style>
    /* Reset body */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: "Segoe UI", sans-serif;
      direction: rtl;
    }

    /* Canvas occupies central part of screen */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #1a1a1a;
    }

    /* Overlays for start and game‑over screens */
    #startScreen,
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      text-align: center;
      z-index: 10;
    }

    /* Buttons style */
    button {
      margin-top: 16px;
      padding: 12px 24px;
      font-size: 18px;
      background: #4caf50;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }

    /* Mobile control buttons */
    #uiControls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: none;
      justify-content: center;
      z-index: 9;
  /* Ensure mobile buttons retain left-to-right order even in RTL layouts */
  direction: ltr;
    }

    .ui-btn {
      width: 64px;
      height: 64px;
      margin: 0 16px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 32px;
      line-height: 64px;
      text-align: center;
      pointer-events: auto;
      user-select: none;
    }

    /* Life hearts container */
    #lifeContainer {
      position: absolute;
      top: 8px;
      left: 8px;
      display: flex;
      z-index: 5;
    }

    .lifeHeart {
      width: 24px;
      height: 24px;
      margin-right: 4px;
    }

    /* Score display */
    #scoreDisplay {
      position: absolute;
      top: 8px;
      right: 8px;
      color: #fff;
      font-size: 20px;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="450"></canvas>

  <div id="startScreen">
    <h1>פנדה בזירה</h1>
    <p>אסוף את הכוכבים והיזהר מהשור.</p>
    <button id="startBtn">התחל</button>
  </div>

  <div id="gameOverScreen" style="display:none;">
    <h1>Game Over</h1>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">שחק שוב</button>
  </div>

  <!-- On‑screen controls for mobile -->
  <div id="uiControls">
    <div class="ui-btn" id="leftBtn">◄</div>
    <div class="ui-btn" id="jumpBtn">▲</div>
    <div class="ui-btn" id="rightBtn">►</div>
  </div>

  <!-- Life hearts and score display -->
  <div id="lifeContainer"></div>
  <div id="scoreDisplay">0</div>

  <script>
    (function() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      // Disable image smoothing for crisp pixel-art look
      ctx.imageSmoothingEnabled = false;
      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      // Load pixel art assets for arcade-style graphics
      const backgroundImg = new Image();
      backgroundImg.src = 'assets/burning.png';
      const minotaurImg = new Image();
      minotaurImg.src = 'assets/minotaur.png';
      // Panda sprite sheet for pixel-art player
      const pandaImg = new Image();
      pandaImg.src = 'assets/panda.png';

      // Physics constants
      const GRAVITY = 0.5;
      const MOVE_SPEED = 4;
      const JUMP_SPEED = -11;

      // Game state
      let gameState = 'start'; // 'start', 'playing', 'gameover'
      let lastFrameTime = 0;

      // Containers for UI elements
      const startScreen = document.getElementById('startScreen');
      const gameOverScreen = document.getElementById('gameOverScreen');
      const finalScoreEl = document.getElementById('finalScore');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const uiControls = document.getElementById('uiControls');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const jumpBtn = document.getElementById('jumpBtn');
      const lifeContainer = document.getElementById('lifeContainer');
      const scoreDisplay = document.getElementById('scoreDisplay');

      // Input state
      let keys = {
        left: false,
        right: false,
        jump: false
      };

      // Helper to detect mobile
      function isMobile() {
        return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|BlackBerry/i.test(navigator.userAgent);
      }

      /* Classes */
      class Player {
        constructor() {
          this.w = 32;
          this.h = 40;
          this.x = WIDTH / 2 - this.w / 2;
          this.y = HEIGHT - 60 - this.h;
          this.vx = 0;
          this.vy = 0;
          this.onGround = false;
        }
        update() {
          // Horizontal movement
          if (keys.left) this.vx = -MOVE_SPEED;
          else if (keys.right) this.vx = MOVE_SPEED;
          else this.vx = 0;
          // Jump
          if (keys.jump && this.onGround) {
            this.vy = JUMP_SPEED;
            this.onGround = false;
          }
          // Apply gravity
          this.vy += GRAVITY;
          // Limit fall speed
          if (this.vy > 12) this.vy = 12;

          // Update position
          this.x += this.vx;
          this.y += this.vy;

          // World bounds
          if (this.x < 0) this.x = 0;
          if (this.x + this.w > WIDTH) this.x = WIDTH - this.w;
          // Prevent the player from exiting above the canvas
          if (this.y < 0) {
            this.y = 0;
            this.vy = 0;
          }

          // Ground collision
          if (this.y + this.h >= groundLevel) {
            this.y = groundLevel - this.h;
            this.vy = 0;
            this.onGround = true;
          }
          // Obstacle collision: check landing on top of platforms
          for (const obs of obstacles) {
            // Check vertical collision when falling
            if (
              this.vy >= 0 &&
              this.x + this.w > obs.x &&
              this.x < obs.x + obs.w &&
              this.y + this.h <= obs.y + obs.h &&
              this.y + this.h + this.vy >= obs.y
            ) {
              this.y = obs.y - this.h;
              this.vy = 0;
              this.onGround = true;
            }
          }
        }
        draw(ctx) {
          const px = this.x;
          const py = this.y;
          // If sprite sheet loaded, draw pixel-art panda and exit early.  
          // Force fallback drawing by short‑circuiting this condition
          if (false && pandaImg.complete && pandaImg.naturalWidth) {
            const cols = 5;
            const rows = 4;
            const frameW = pandaImg.width / cols;
            const frameH = pandaImg.height / rows;
            ctx.drawImage(pandaImg, 0, 0, frameW, frameH, px, py - 8, this.w, this.h + 8);
            return;
          }
          // Draw a cute and friendly panda when no sprite sheet is loaded
          // Head
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          const headRadius = this.h * 0.38;
          const headX = px + this.w / 2;
          const headY = py + this.h * 0.2;
          ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          ctx.stroke();
          // Ears
          ctx.fillStyle = '#000000';
          const earRadius = this.h * 0.14;
          ctx.beginPath();
          ctx.arc(headX - this.w * 0.32, py + this.h * 0.02, earRadius, 0, Math.PI * 2);
          ctx.arc(headX + this.w * 0.32, py + this.h * 0.02, earRadius, 0, Math.PI * 2);
          ctx.fill();
          // Eyes: large white eyes with highlights
          ctx.fillStyle = '#ffffff';
          const eyeRadius = this.h * 0.08;
          ctx.beginPath();
          ctx.arc(headX - this.w * 0.18, py + this.h * 0.22, eyeRadius, 0, Math.PI * 2);
          ctx.arc(headX + this.w * 0.18, py + this.h * 0.22, eyeRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000000';
          const pupilRadius = this.h * 0.03;
          ctx.beginPath();
          ctx.arc(headX - this.w * 0.18, py + this.h * 0.22, pupilRadius, 0, Math.PI * 2);
          ctx.arc(headX + this.w * 0.18, py + this.h * 0.22, pupilRadius, 0, Math.PI * 2);
          ctx.fill();
          // Add rosy cheeks
          ctx.fillStyle = '#f5a5c5';
          const cheekRadius = this.h * 0.05;
          ctx.beginPath();
          ctx.arc(headX - this.w * 0.25, py + this.h * 0.28, cheekRadius, 0, Math.PI * 2);
          ctx.arc(headX + this.w * 0.25, py + this.h * 0.28, cheekRadius, 0, Math.PI * 2);
          ctx.fill();
          // Simple smile
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(headX, py + this.h * 0.27, this.h * 0.12, Math.PI * 0.1, Math.PI * 0.9);
          ctx.stroke();
          // Body in soft blue suit
          ctx.fillStyle = '#8cc0de';
          const bodyY = py + this.h * 0.36;
          const bodyH = this.h * 0.64;
          ctx.fillRect(px, bodyY, this.w, bodyH);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          ctx.strokeRect(px, bodyY, this.w, bodyH);
          // Belt in soft yellow
          ctx.fillStyle = '#f5e663';
          ctx.fillRect(px, py + this.h * 0.68, this.w, this.h * 0.07);
          // Gentle cape in pastel pink
          ctx.fillStyle = '#f4a4a8';
          ctx.beginPath();
          ctx.moveTo(px + this.w / 2, py + this.h * 0.42);
          ctx.lineTo(px + this.w / 2 + this.w, py + this.h * 0.72);
          ctx.lineTo(px + this.w / 2 - this.w, py + this.h * 0.72);
          ctx.closePath();
          ctx.fill();
        }
        get rect() {
          return { x: this.x, y: this.y, w: this.w, h: this.h };
        }
      }

      class Star {
        constructor(x) {
          // Stars spawn high above the arena and fall down until they land
          this.size = 24; // Larger size for retro arcade feel
          this.x = x;
          // Start above the visible screen so stars fall into the arena
          this.y = -this.size;
          // Vertical speed; randomize a bit to vary the fall
          this.vy = 1 + Math.random() * 1;
          this.collected = false;
          this.landed = false;
        }
        update() {
          // Make star fall until it lands on the ground
          if (!this.landed) {
            this.y += this.vy;
            // When the bottom of the star reaches the ground, stop it there
            if (this.y + this.size / 2 >= groundLevel) {
              this.y = groundLevel - this.size / 2;
              this.vy = 0;
              this.landed = true;
            }
          }
          // Stars will be marked as collected when the player touches them
        }
        draw(ctx) {
          drawStar(ctx, this.x, this.y, 5, this.size / 2, this.size);
        }
        get rect() {
          return { x: this.x - this.size / 2, y: this.y - this.size / 2, w: this.size, h: this.size };
        }
      }

      class Spell {
        constructor(x, y, vx, vy) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.size = 16; // Larger size for retro arcade style spells
          this.active = true;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          // Remove if off screen
          if (this.x < -this.size || this.x > WIDTH + this.size || this.y > HEIGHT + this.size || this.y < -this.size) {
            this.active = false;
          }
        }
        draw(ctx) {
          // Draw a glowing sphere
          ctx.save();
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
          // Render the projectile as a fiery orb – start bright orange fading to transparent
          gradient.addColorStop(0, '#ff6a00');
          gradient.addColorStop(1, 'rgba(255,106,0,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        get rect() {
          return { x: this.x - this.size, y: this.y - this.size, w: this.size * 2, h: this.size * 2 };
        }
      }

      class Minotaur {
        constructor() {
          // Use a larger size so the minotaur stands out
          this.w = 120;
          this.h = 120;
          // Start near the center of the screen
          this.x = WIDTH / 2 - this.w / 2;
          // Start on the ground
          this.y = groundLevel - this.h;
          // Horizontal and vertical velocity for movement and jumping
          this.vx = 2;
          this.vy = 0;
          this.onGround = false;
          this.jumpTimer = 0;
        }
        update() {
          // Apply horizontal movement and bounce off edges
          this.x += this.vx;
          if (this.x <= 0 || this.x + this.w >= WIDTH) {
            this.vx *= -1;
            // Clamp within bounds
            if (this.x <= 0) this.x = 0;
            if (this.x + this.w >= WIDTH) this.x = WIDTH - this.w;
          }
          // Apply gravity
          this.vy += GRAVITY;
          this.y += this.vy;
          // Ground collision
          if (this.y + this.h >= groundLevel) {
            this.y = groundLevel - this.h;
            this.vy = 0;
            this.onGround = true;
          } else {
            this.onGround = false;
          }
          // Randomly jump if on ground
          if (this.onGround) {
            this.jumpTimer++;
            if (this.jumpTimer > 120 && Math.random() < 0.03) {
              this.vy = JUMP_SPEED * 1.2;
              this.onGround = false;
              this.jumpTimer = 0;
            }
          }
          // TODO: Could add more complex patterns or targeted charges here
        }
        draw(ctx) {
          // Draw the minotaur using a pixel art sprite. Crop the first frame from the sprite sheet.
          // Force use of the vector fallback by short‑circuiting the image condition
          if (false && minotaurImg.complete && minotaurImg.naturalWidth) {
            const cols = 8; // number of columns in sprite sheet
            const rows = 5; // number of rows in sprite sheet
            const frameW = minotaurImg.width / cols;
            const frameH = minotaurImg.height / rows;
            // Use first frame (row 0, col 0)
            ctx.drawImage(
              minotaurImg,
              0,
              0,
              frameW,
              frameH,
              this.x,
              this.y,
              this.w,
              this.h
            );
          } else {
            // If the sprite isn't loaded, draw a friendly bull in a soft, welcoming style.
            // Body: light brown rectangle with a dark outline
            ctx.fillStyle = '#c68a6b';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            roundRect(ctx, this.x, this.y, this.w, this.h, 8, true, true);
            // Horns: gentle beige
            ctx.fillStyle = '#f5e6ca';
            ctx.beginPath();
            ctx.moveTo(this.x + 15, this.y - 8);
            ctx.lineTo(this.x + 8, this.y - 28);
            ctx.lineTo(this.x + 30, this.y - 12);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(this.x + this.w - 15, this.y - 8);
            ctx.lineTo(this.x + this.w - 8, this.y - 28);
            ctx.lineTo(this.x + this.w - 30, this.y - 12);
            ctx.closePath();
            ctx.fill();
            // Eyes: large white eyes with black pupils
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(this.x + 25, this.y + 25, 8, 0, Math.PI * 2);
            ctx.arc(this.x + this.w - 25, this.y + 25, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(this.x + 25, this.y + 25, 3, 0, Math.PI * 2);
            ctx.arc(this.x + this.w - 25, this.y + 25, 3, 0, Math.PI * 2);
            ctx.fill();
            // Gentle smile
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            const mouthY = this.y + 60;
            const mouthRadius = 20;
            ctx.arc(this.x + this.w / 2, mouthY, mouthRadius, Math.PI * 0.1, Math.PI * 0.9);
            ctx.stroke();
            // Nose ring remains but toned down in color
            ctx.strokeStyle = '#d6b600';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x + this.w / 2, this.y + 50, 8, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      class Obstacle {
        constructor(x, y, w, h) {
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;
        }
        draw(ctx) {
          ctx.fillStyle = '#555';
          ctx.fillRect(this.x, this.y, this.w, this.h);
        }
      }

      // Helper functions
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === 'undefined') {
          r = 5;
        }
        if (typeof r === 'number') {
          r = { tl: r, tr: r, br: r, bl: r };
        } else {
          var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (var side in defaultRadius) {
            r[side] = r[side] || defaultRadius[side];
          }
        }
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      // Draw a star shape at x,y with inner and outer radius
      function drawStar(ctx, cx, cy, spikes, innerR, outerR) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerR);
        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerR;
          y = cy + Math.sin(rot) * outerR;
          ctx.lineTo(x, y);
          rot += step;
          x = cx + Math.cos(rot) * innerR;
          y = cy + Math.sin(rot) * innerR;
          ctx.lineTo(x, y);
          rot += step;
        }
        ctx.lineTo(cx, cy - outerR);
        ctx.closePath();
        ctx.fillStyle = '#ffdf00';
        ctx.fill();
        ctx.strokeStyle = '#cbb700';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // Game world variables
      let player;
      let minotaur;
      let obstacles = [];
      let spells = [];
      let lightnings = [];
      let stars = [];
      let lives;
      let score;
      const groundLevel = HEIGHT - 40;
      let starTimer = 0;
      let spellTimer = 0;

      // Initialize the level with static obstacles
      function initGame() {
        player = new Player();
        minotaur = new Minotaur();
        obstacles = [];
        spells = [];
        lightnings = [];
        stars = [];
        // Add some platforms and stones
        obstacles.push(new Obstacle(120, groundLevel - 140, 120, 20));
        obstacles.push(new Obstacle(320, groundLevel - 220, 140, 20));
        obstacles.push(new Obstacle(560, groundLevel - 180, 100, 20));
        obstacles.push(new Obstacle(700, groundLevel - 80, 80, 20));
        obstacles.push(new Obstacle(20, groundLevel - 80, 80, 20));
        lives = 3;
        score = 0;
        updateLivesDisplay();
        updateScoreDisplay();
        starTimer = 0;
        spellTimer = 0;
      }

      // Update hearts display
      function updateLivesDisplay() {
        lifeContainer.innerHTML = '';
        for (let i = 0; i < lives; i++) {
          const img = document.createElement('div');
          img.className = 'lifeHeart';
          // Draw heart using CSS background
          img.style.background = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\'><path fill=\'%23ff2f2f\' d=\'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z\'/></svg>") no-repeat center/contain';
          lifeContainer.appendChild(img);
        }
      }

      // Update score display
      function updateScoreDisplay() {
        scoreDisplay.textContent = score;
      }

      // Spawn a new falling star at a random horizontal position
      function spawnStar() {
        // Choose a horizontal position with some margin from the edges
        const x = 20 + Math.random() * (WIDTH - 40);
        // Create a falling star at this x position. It will spawn above the arena and fall down.
        stars.push(new Star(x));
      }

      // Spawn spells from the minotaur directed roughly toward the player
      function spawnSpell() {
        const startX = minotaur.x + minotaur.w / 2;
        const startY = minotaur.y + minotaur.h;
        // Aim towards player
        const dx = player.x + player.w / 2 - startX;
        const dy = player.y + player.h / 2 - startY;
        const len = Math.sqrt(dx * dx + dy * dy);
        const speed = 3 + Math.random();
        const vx = (dx / len) * speed;
        const vy = (dy / len) * speed;
        spells.push(new Spell(startX, startY, vx, vy));
      }

      // Collision detection between two rectangles
      function rectsIntersect(r1, r2) {
        return (
          r1.x < r2.x + r2.w &&
          r1.x + r1.w > r2.x &&
          r1.y < r2.y + r2.h &&
          r1.y + r1.h > r2.y
        );
      }

      // Handle all game logic updates
      function update(delta) {
        player.update();
        minotaur.update();
        // Update stars
        for (const star of stars) star.update();
        // Remove collected or off‑screen stars
        stars = stars.filter(s => !s.collected);
        // Update spells
        for (const sp of spells) sp.update();
        spells = spells.filter(sp => sp.active);
        // Update lightning strikes
        for (const l of lightnings) l.update();
        lightnings = lightnings.filter(l => l.active);
        // Generate stars periodically
        starTimer += delta;
        if (starTimer > 4000) {
          spawnStar();
          starTimer = 0;
        }
        // Generate spells periodically
        spellTimer += delta;
        if (spellTimer > 2500) {
          spawnSpell();
          spellTimer = 0;
        }
        // Check collisions between player and stars
        for (const star of stars) {
          if (!star.collected && rectsIntersect(player.rect, star.rect)) {
            star.collected = true;
            score += 1;
            updateScoreDisplay();
          }
        }
        // Check collisions between player and spells
        for (const sp of spells) {
          if (rectsIntersect(player.rect, sp.rect)) {
            sp.active = false;
            lives -= 1;
            updateLivesDisplay();
            if (lives <= 0) {
              // End game
              showGameOver();
              return;
            }
          }
        }

        // Check collisions between player and lightning strikes
        for (const l of lightnings) {
          if (rectsIntersect(player.rect, l.rect)) {
            // Apply knockback: push player upward and sideways
            player.vy = JUMP_SPEED * 1.2;
            // Push horizontally away from the lightning center
            if (player.x + player.w / 2 < l.x + l.w / 2) {
              player.vx = -MOVE_SPEED * 2;
            } else {
              player.vx = MOVE_SPEED * 2;
            }
            // Deduct a life when struck by lightning
            lives -= 1;
            updateLivesDisplay();
            // Remove the lightning so it doesn't repeatedly damage
            l.active = false;
            if (lives <= 0) {
              showGameOver();
              return;
            }
          }
        }
      }

      // Draw everything on the canvas
      function draw() {
        // Clear
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw background with burning city vibe
        drawBackground();
        // Draw obstacles
        for (const obs of obstacles) obs.draw(ctx);
        // Draw stars
        for (const star of stars) star.draw(ctx);
        // Draw spells
        for (const sp of spells) sp.draw(ctx);
        // Draw lightning strikes
        for (const l of lightnings) l.draw(ctx);
        // Draw minotaur
        minotaur.draw(ctx);
        // Draw player
        player.draw(ctx);
        // Apply a semi-transparent tint over the scene to give a retro arcade vibe
        ctx.fillStyle = 'rgba(50, 30, 30, 0.2)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
      }

      // Background art: simple gradient and silhouettes
      function drawBackground() {
        // Draw a bright daytime sky with fluffy clouds for a vintage arcade feel.
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        // Add several cloud shapes using overlapping circles to create a retro look.
        const clouds = [
          { x: 80, y: 60, w: 40 },
          { x: 260, y: 100, w: 50 },
          { x: 480, y: 80, w: 60 },
          { x: 620, y: 140, w: 45 }
        ];
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        for (const c of clouds) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.w, 0, Math.PI * 2);
          ctx.arc(c.x + c.w * 0.8, c.y + c.w * 0.2, c.w * 1.2, 0, Math.PI * 2);
          ctx.arc(c.x - c.w * 0.8, c.y + c.w * 0.2, c.w * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Main loop using requestAnimationFrame
      function gameLoop(timestamp) {
        if (gameState !== 'playing') return;
        if (!lastFrameTime) lastFrameTime = timestamp;
        const delta = timestamp - lastFrameTime;
        lastFrameTime = timestamp;
        update(delta);
        draw();
        requestAnimationFrame(gameLoop);
      }

      function showGameOver() {
        gameState = 'gameover';
        finalScoreEl.textContent = 'Score: ' + score;
        gameOverScreen.style.display = 'flex';
        uiControls.style.display = 'none';
      }

      /* Input handling */
      function addKeyboardListeners() {
        window.addEventListener('keydown', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
          if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.jump = true;
        });
        window.addEventListener('keyup', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
          if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.jump = false;
        });
      }
      function addTouchListeners() {
        let leftInterval, rightInterval;
        function setLeft(val) { keys.left = val; if (!val && leftInterval) { clearInterval(leftInterval); leftInterval = null; } }
        function setRight(val) { keys.right = val; if (!val && rightInterval) { clearInterval(rightInterval); rightInterval = null; } }
        leftBtn.addEventListener('touchstart', e => { e.preventDefault(); setLeft(true); });
        leftBtn.addEventListener('touchend', e => { e.preventDefault(); setLeft(false); });
        rightBtn.addEventListener('touchstart', e => { e.preventDefault(); setRight(true); });
        rightBtn.addEventListener('touchend', e => { e.preventDefault(); setRight(false); });
        jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.jump = true; });
        jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys.jump = false; });
      }

      // Button handlers
      startBtn.addEventListener('click', () => {
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        gameState = 'playing';
        initGame();
        lastFrameTime = 0;
        if (isMobile()) uiControls.style.display = 'flex';
        requestAnimationFrame(gameLoop);
      });
      restartBtn.addEventListener('click', () => {
        gameOverScreen.style.display = 'none';
        gameState = 'playing';
        initGame();
        lastFrameTime = 0;
        if (isMobile()) uiControls.style.display = 'flex';
        requestAnimationFrame(gameLoop);
      });

      // Setup input listeners
      addKeyboardListeners();
      addTouchListeners();
    })();
  </script>
</body>
</html>