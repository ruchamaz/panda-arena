<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>פנדה בזירה</title>
  <style>
    /* Reset body */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: "Segoe UI", sans-serif;
      direction: rtl;
    }

    /* Canvas occupies central part of screen */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #1a1a1a;
    }

    /* Overlays for start and game‑over screens */
    #startScreen,
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      text-align: center;
      z-index: 10;
    }

    /* Buttons style */
    button {
      margin-top: 16px;
      padding: 12px 24px;
      font-size: 18px;
      background: #4caf50;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }

    /* Mobile control buttons */
    #uiControls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: none;
      justify-content: center;
      z-index: 9;
    }

    .ui-btn {
      width: 64px;
      height: 64px;
      margin: 0 16px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 32px;
      line-height: 64px;
      text-align: center;
      pointer-events: auto;
      user-select: none;
    }

    /* Life hearts container */
    #lifeContainer {
      position: absolute;
      top: 8px;
      left: 8px;
      display: flex;
      z-index: 5;
    }

    .lifeHeart {
      width: 24px;
      height: 24px;
      margin-right: 4px;
    }

    /* Score display */
    #scoreDisplay {
      position: absolute;
      top: 8px;
      right: 8px;
      color: #fff;
      font-size: 20px;
      z-index: 5;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="450"></canvas>

  <div id="startScreen">
    <h1>פנדה בזירה</h1>
    <p>אסוף את הכוכבים והיזהר מהשור.</p>
    <button id="startBtn">התחל</button>
  </div>

  <div id="gameOverScreen" style="display:none;">
    <h1>Game Over</h1>
    <p id="finalScore">Score: 0</p>
    <button id="restartBtn">שחק שוב</button>
  </div>

  <!-- On‑screen controls for mobile -->
  <div id="uiControls">
    <div class="ui-btn" id="leftBtn">◄</div>
    <div class="ui-btn" id="jumpBtn">▲</div>
    <div class="ui-btn" id="rightBtn">►</div>
  </div>

  <!-- Life hearts and score display -->
  <div id="lifeContainer"></div>
  <div id="scoreDisplay">0</div>

  <script>
    (function() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;

      // Physics constants
      const GRAVITY = 0.5;
      const MOVE_SPEED = 4;
      const JUMP_SPEED = -11;

      // Game state
      let gameState = 'start'; // 'start', 'playing', 'gameover'
      let lastFrameTime = 0;

      // Containers for UI elements
      const startScreen = document.getElementById('startScreen');
      const gameOverScreen = document.getElementById('gameOverScreen');
      const finalScoreEl = document.getElementById('finalScore');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const uiControls = document.getElementById('uiControls');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const jumpBtn = document.getElementById('jumpBtn');
      const lifeContainer = document.getElementById('lifeContainer');
      const scoreDisplay = document.getElementById('scoreDisplay');

      // Input state
      let keys = {
        left: false,
        right: false,
        jump: false
      };

      // Helper to detect mobile
      function isMobile() {
        return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|BlackBerry/i.test(navigator.userAgent);
      }

      /* Classes */
      class Player {
        constructor() {
          this.w = 32;
          this.h = 40;
          this.x = WIDTH / 2 - this.w / 2;
          this.y = HEIGHT - 60 - this.h;
          this.vx = 0;
          this.vy = 0;
          this.onGround = false;
        }
        update() {
          // Horizontal movement
          if (keys.left) this.vx = -MOVE_SPEED;
          else if (keys.right) this.vx = MOVE_SPEED;
          else this.vx = 0;
          // Jump
          if (keys.jump && this.onGround) {
            this.vy = JUMP_SPEED;
            this.onGround = false;
          }
          // Apply gravity
          this.vy += GRAVITY;
          // Limit fall speed
          if (this.vy > 12) this.vy = 12;

          // Update position
          this.x += this.vx;
          this.y += this.vy;

          // World bounds
          if (this.x < 0) this.x = 0;
          if (this.x + this.w > WIDTH) this.x = WIDTH - this.w;

          // Ground collision
          if (this.y + this.h >= groundLevel) {
            this.y = groundLevel - this.h;
            this.vy = 0;
            this.onGround = true;
          }
          // Obstacle collision: check landing on top of platforms
          for (const obs of obstacles) {
            // Check vertical collision when falling
            if (
              this.vy >= 0 &&
              this.x + this.w > obs.x &&
              this.x < obs.x + obs.w &&
              this.y + this.h <= obs.y + obs.h &&
              this.y + this.h + this.vy >= obs.y
            ) {
              this.y = obs.y - this.h;
              this.vy = 0;
              this.onGround = true;
            }
          }
        }
        draw(ctx) {
          // Draw panda body (rounded rectangle)
          const px = this.x;
          const py = this.y;
          // Body
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          roundRect(ctx, px, py, this.w, this.h, 6, true, true);
          // Ears
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(px + 6, py - 6, 6, 0, Math.PI * 2);
          ctx.arc(px + this.w - 6, py - 6, 6, 0, Math.PI * 2);
          ctx.fill();
          // Eyes
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(px + 10, py + 12, 3, 0, Math.PI * 2);
          ctx.arc(px + this.w - 10, py + 12, 3, 0, Math.PI * 2);
          ctx.fill();
          // Cape
          ctx.fillStyle = 'rgba(255,0,0,0.5)';
          ctx.beginPath();
          ctx.moveTo(px + this.w / 2, py + 10);
          ctx.lineTo(px + this.w / 2 + 20, py + this.h + 10);
          ctx.lineTo(px + this.w / 2 - 20, py + this.h + 10);
          ctx.closePath();
          ctx.fill();
        }
        get rect() {
          return { x: this.x, y: this.y, w: this.w, h: this.h };
        }
      }

      class Star {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = 16;
          this.collected = false;
        }
        update() {
          // Stars fall slowly downward
          this.y += 0.5;
          if (this.y > HEIGHT) this.collected = true;
        }
        draw(ctx) {
          drawStar(ctx, this.x, this.y, 5, this.size / 2, this.size);
        }
        get rect() {
          return { x: this.x - this.size / 2, y: this.y - this.size / 2, w: this.size, h: this.size };
        }
      }

      class Spell {
        constructor(x, y, vx, vy) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.size = 12;
          this.active = true;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          // Remove if off screen
          if (this.x < -this.size || this.x > WIDTH + this.size || this.y > HEIGHT + this.size || this.y < -this.size) {
            this.active = false;
          }
        }
        draw(ctx) {
          // Draw a glowing sphere
          ctx.save();
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
          gradient.addColorStop(0, '#ff00ff');
          gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        get rect() {
          return { x: this.x - this.size, y: this.y - this.size, w: this.size * 2, h: this.size * 2 };
        }
      }

      class Minotaur {
        constructor() {
          this.w = 60;
          this.h = 60;
          this.x = WIDTH / 2 - this.w / 2;
          this.y = 60;
        }
        update() {
          // Could add movement or pattern later
        }
        draw(ctx) {
          // Body
          ctx.fillStyle = '#7b4f2c';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          roundRect(ctx, this.x, this.y, this.w, this.h, 8, true, true);
          // Horns
          ctx.fillStyle = '#f5f5f5';
          ctx.beginPath();
          ctx.moveTo(this.x + 10, this.y - 5);
          ctx.lineTo(this.x + 5, this.y - 20);
          ctx.lineTo(this.x + 15, this.y - 10);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(this.x + this.w - 10, this.y - 5);
          ctx.lineTo(this.x + this.w - 5, this.y - 20);
          ctx.lineTo(this.x + this.w - 15, this.y - 10);
          ctx.closePath();
          ctx.fill();
          // Eyes
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(this.x + 15, this.y + 18, 5, 0, Math.PI * 2);
          ctx.arc(this.x + this.w - 15, this.y + 18, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(this.x + 15, this.y + 18, 2, 0, Math.PI * 2);
          ctx.arc(this.x + this.w - 15, this.y + 18, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      class Obstacle {
        constructor(x, y, w, h) {
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;
        }
        draw(ctx) {
          ctx.fillStyle = '#555';
          ctx.fillRect(this.x, this.y, this.w, this.h);
        }
      }

      // Helper functions
      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === 'undefined') {
          r = 5;
        }
        if (typeof r === 'number') {
          r = { tl: r, tr: r, br: r, bl: r };
        } else {
          var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (var side in defaultRadius) {
            r[side] = r[side] || defaultRadius[side];
          }
        }
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      // Draw a star shape at x,y with inner and outer radius
      function drawStar(ctx, cx, cy, spikes, innerR, outerR) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerR);
        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerR;
          y = cy + Math.sin(rot) * outerR;
          ctx.lineTo(x, y);
          rot += step;
          x = cx + Math.cos(rot) * innerR;
          y = cy + Math.sin(rot) * innerR;
          ctx.lineTo(x, y);
          rot += step;
        }
        ctx.lineTo(cx, cy - outerR);
        ctx.closePath();
        ctx.fillStyle = '#ffdf00';
        ctx.fill();
        ctx.strokeStyle = '#cbb700';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // Game world variables
      let player;
      let minotaur;
      let obstacles = [];
      let spells = [];
      let stars = [];
      let lives;
      let score;
      const groundLevel = HEIGHT - 40;
      let starTimer = 0;
      let spellTimer = 0;

      // Initialize the level with static obstacles
      function initGame() {
        player = new Player();
        minotaur = new Minotaur();
        obstacles = [];
        spells = [];
        stars = [];
        // Add some platforms and stones
        obstacles.push(new Obstacle(120, groundLevel - 140, 120, 20));
        obstacles.push(new Obstacle(320, groundLevel - 220, 140, 20));
        obstacles.push(new Obstacle(560, groundLevel - 180, 100, 20));
        obstacles.push(new Obstacle(700, groundLevel - 80, 80, 20));
        obstacles.push(new Obstacle(20, groundLevel - 80, 80, 20));
        lives = 3;
        score = 0;
        updateLivesDisplay();
        updateScoreDisplay();
        starTimer = 0;
        spellTimer = 0;
      }

      // Update hearts display
      function updateLivesDisplay() {
        lifeContainer.innerHTML = '';
        for (let i = 0; i < lives; i++) {
          const img = document.createElement('div');
          img.className = 'lifeHeart';
          // Draw heart using CSS background
          img.style.background = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\'><path fill=\'%23ff2f2f\' d=\'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z\'/></svg>") no-repeat center/contain';
          lifeContainer.appendChild(img);
        }
      }

      // Update score display
      function updateScoreDisplay() {
        scoreDisplay.textContent = score;
      }

      // Spawn a new star at random x above the screen
      function spawnStar() {
        const x = 50 + Math.random() * (WIDTH - 100);
        const star = new Star(x, -20);
        stars.push(star);
      }

      // Spawn spells from the minotaur directed roughly toward the player
      function spawnSpell() {
        const startX = minotaur.x + minotaur.w / 2;
        const startY = minotaur.y + minotaur.h;
        // Aim towards player
        const dx = player.x + player.w / 2 - startX;
        const dy = player.y + player.h / 2 - startY;
        const len = Math.sqrt(dx * dx + dy * dy);
        const speed = 3 + Math.random();
        const vx = (dx / len) * speed;
        const vy = (dy / len) * speed;
        spells.push(new Spell(startX, startY, vx, vy));
      }

      // Collision detection between two rectangles
      function rectsIntersect(r1, r2) {
        return (
          r1.x < r2.x + r2.w &&
          r1.x + r1.w > r2.x &&
          r1.y < r2.y + r2.h &&
          r1.y + r1.h > r2.y
        );
      }

      // Handle all game logic updates
      function update(delta) {
        player.update();
        minotaur.update();
        // Update stars
        for (const star of stars) star.update();
        // Remove collected or off‑screen stars
        stars = stars.filter(s => !s.collected);
        // Update spells
        for (const sp of spells) sp.update();
        spells = spells.filter(sp => sp.active);
        // Generate stars periodically
        starTimer += delta;
        if (starTimer > 4000) {
          spawnStar();
          starTimer = 0;
        }
        // Generate spells periodically
        spellTimer += delta;
        if (spellTimer > 2500) {
          spawnSpell();
          spellTimer = 0;
        }
        // Check collisions between player and stars
        for (const star of stars) {
          if (!star.collected && rectsIntersect(player.rect, star.rect)) {
            star.collected = true;
            score += 1;
            updateScoreDisplay();
          }
        }
        // Check collisions between player and spells
        for (const sp of spells) {
          if (rectsIntersect(player.rect, sp.rect)) {
            sp.active = false;
            lives -= 1;
            updateLivesDisplay();
            if (lives <= 0) {
              // End game
              showGameOver();
              return;
            }
          }
        }
      }

      // Draw everything on the canvas
      function draw() {
        // Clear
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw background with burning city vibe
        drawBackground();
        // Draw obstacles
        for (const obs of obstacles) obs.draw(ctx);
        // Draw stars
        for (const star of stars) star.draw(ctx);
        // Draw spells
        for (const sp of spells) sp.draw(ctx);
        // Draw minotaur
        minotaur.draw(ctx);
        // Draw player
        player.draw(ctx);
      }

      // Background art: simple gradient and silhouettes
      function drawBackground() {
        // Sky gradient
        const sky = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        sky.addColorStop(0, '#1a1a1a');
        sky.addColorStop(1, '#330000');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        // Buildings silhouette
        ctx.fillStyle = '#0d0d0d';
        for (let i = 0; i < 8; i++) {
          const bWidth = 50 + Math.random() * 70;
          const bHeight = 100 + Math.random() * 120;
          const bx = i * 100 + Math.random() * 20;
          const by = groundLevel - bHeight + Math.random() * 30;
          ctx.fillRect(bx, by, bWidth, bHeight);
        }
        // Flames
        for (let i = 0; i < 30; i++) {
          const fx = Math.random() * WIDTH;
          const fy = groundLevel - Math.random() * 60;
          const fw = 6;
          const fh = 18 + Math.random() * 20;
          const grd = ctx.createLinearGradient(fx, fy, fx, fy + fh);
          grd.addColorStop(0, 'rgba(255, 80, 0, 0.8)');
          grd.addColorStop(0.5, 'rgba(255, 150, 0, 0.6)');
          grd.addColorStop(1, 'rgba(255, 220, 0, 0.0)');
          ctx.fillStyle = grd;
          ctx.fillRect(fx, fy, fw, fh);
        }
        // Ground
        ctx.fillStyle = '#2c2c2c';
        ctx.fillRect(0, groundLevel, WIDTH, HEIGHT - groundLevel);
      }

      // Main loop using requestAnimationFrame
      function gameLoop(timestamp) {
        if (gameState !== 'playing') return;
        if (!lastFrameTime) lastFrameTime = timestamp;
        const delta = timestamp - lastFrameTime;
        lastFrameTime = timestamp;
        update(delta);
        draw();
        requestAnimationFrame(gameLoop);
      }

      function showGameOver() {
        gameState = 'gameover';
        finalScoreEl.textContent = 'Score: ' + score;
        gameOverScreen.style.display = 'flex';
        uiControls.style.display = 'none';
      }

      /* Input handling */
      function addKeyboardListeners() {
        window.addEventListener('keydown', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
          if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.jump = true;
        });
        window.addEventListener('keyup', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
          if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.jump = false;
        });
      }
      function addTouchListeners() {
        let leftInterval, rightInterval;
        function setLeft(val) { keys.left = val; if (!val && leftInterval) { clearInterval(leftInterval); leftInterval = null; } }
        function setRight(val) { keys.right = val; if (!val && rightInterval) { clearInterval(rightInterval); rightInterval = null; } }
        leftBtn.addEventListener('touchstart', e => { e.preventDefault(); setLeft(true); });
        leftBtn.addEventListener('touchend', e => { e.preventDefault(); setLeft(false); });
        rightBtn.addEventListener('touchstart', e => { e.preventDefault(); setRight(true); });
        rightBtn.addEventListener('touchend', e => { e.preventDefault(); setRight(false); });
        jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.jump = true; });
        jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys.jump = false; });
      }

      // Button handlers
      startBtn.addEventListener('click', () => {
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        gameState = 'playing';
        initGame();
        lastFrameTime = 0;
        if (isMobile()) uiControls.style.display = 'flex';
        requestAnimationFrame(gameLoop);
      });
      restartBtn.addEventListener('click', () => {
        gameOverScreen.style.display = 'none';
        gameState = 'playing';
        initGame();
        lastFrameTime = 0;
        if (isMobile()) uiControls.style.display = 'flex';
        requestAnimationFrame(gameLoop);
      });

      // Setup input listeners
      addKeyboardListeners();
      addTouchListeners();
    })();
  </script>
</body>
</html>